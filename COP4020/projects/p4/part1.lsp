(defun demo()
    (setq fp (open "theString.txt" :direction :input))
    (setq l (read fp "done"))
    (princ "processing ")
	(princ l)
    (fsa l)
)

(defun fsa(l)
    (cond ((null l) "illegal empty string")
		(t (state0 l))
	)
)

(defun StateX(l)
	(cond 
		;end of string: ((null l) "<legal|illegal> state")
		;transitions: ((equal (car l) 'X) (StateX(cdr l)))
		;illegal characters: (t "Illegal character in StateX")
	)
)

(defun state0(l)
    (cond ((null l) "illegal: state 0 is not an accept state")
		((equal (car l) 'x) (state0(cdr l)))
		((equal (car l) 'y) (state1(cdr l)))
		(t "illegal character in State 0")
    )
)

(defun state1(l)
    (cond ((null l) "legal: State 1 is an accept state")
    ((equal (car l) 'x) (state2(cdr l)))
    (t "illegal character in State 1")
    )
)

(defun state2(l)
    (cond ((null l) "illegal: State 2 is not an accept state")
    ((equal (car l) 'x) (state2(cdr l)))
    ((equal (car l) 'y) (state3(cdr l)))
    (t "Illegal character in State 2")
    )
)

(defun state3(l)
    (cond ((null l) "legal: State 3 is an accept state")
    ((equal (car l) 'z) (state4(cdr l)))
    ((equal (car l) 'x) (state3(cdr l)))
    (t "Illegal character in State 3")
    )
)

(defun state4(l)
    (cond ((null l) "illegal: State 4 is not an accept state")
    ((equal (car l) 'a) (state1(cdr l)))
    ((equal (car l) 'x) (state4(cdr l)))
    (t "Illegal character in State 4")
    )
)